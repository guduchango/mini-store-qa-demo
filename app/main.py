import time
from fastapi import FastAPI, HTTPException, Request
from app.schemas import Query
import app.chroma_utils as chroma_utils
import logging
from app.ollama_utils import generate_response

logging.basicConfig(level=logging.INFO, format="%(asctime)s [%(levelname)s] %(message)s")

app = FastAPI()

# Short wait to allow Chroma and Ollama to start up
time.sleep(5)

# Index products only if needed
chroma_utils.index_products_if_empty()

@app.get("/health")
def health_check():
    return {"status": "ok"}

@app.post("/delete_products")
def delete_products():
    try:
        # Get all current IDs in the collection
        ids = chroma_utils.collection.get()["ids"]
        if not ids:
            return {"message": "‚ÑπÔ∏è There were no products to delete."}

        # Explicitly delete those IDs
        chroma_utils.collection.delete(ids=ids)
        return {"message": f"‚úÖ Deleted {len(ids)} products from Chroma."}
    except Exception as e:
        import traceback
        print("Error in /delete_products:", e)
        traceback.print_exc()
        raise HTTPException(status_code=500, detail="Error deleting products.")

@app.post("/query")
async def query_products(request: Request):
    data = await request.json()
    seller_tone = data.get("seller_tone", "")
    client_query = data.get("client_query", "")

    try:
        logging.info("üîé Received query: %s", client_query)

        results = chroma_utils.search_products(client_query, n_results=3)

        documents_list = results.get('documents', [])
        metadatas_list = results.get('metadatas', [])

        logging.info("üì¶ Found documents: %s", documents_list)
        logging.info("üìù Found metadata: %s", metadatas_list)

        if not documents_list or not documents_list[0]:
            logging.warning("‚ùå No related documents found.")
            return {"response": "I couldn‚Äôt find products related to your query."}

        documents = documents_list[0]
        metadatas = metadatas_list[0]

        products = []
        for doc, meta in zip(documents, metadatas):
            products.append({
                "name": meta["name"],
                "category": meta["category"],
                "size": meta["size"],
                "color": meta["color"],
                "price": meta["price"],
                "description": doc,
            })

        data = {
            "context": {
                "seller_tone": seller_tone,
                "products": products
            },
            "client_query": client_query
        }

        logging.info("üöÄ Prompt sent to Ollama:\n%s", data)

        response = generate_response(data)

        logging.info("‚úÖ Response generated by Ollama: %s", response)

        return {
            "response": response,
            "related_products": [
                {
                    "name": meta["name"],
                    "category": meta["category"],
                    "size": meta["size"],
                    "color": meta["color"],
                    "price": meta["price"],
                    "stock": meta["stock"],
                    "image_url": meta["image_url"],
                }
                for meta in metadatas
            ]
        }

    except Exception as e:
        import traceback
        logging.error("‚ùó Error in /query: %s", e)
        traceback.print_exc()
        raise HTTPException(status_code=500, detail="Error processing the query.")
